import {
  Component,
  ErrorFactory,
  FirebaseError,
  index_esm_default
} from "./chunk-HNTH5UNU.js";
import {
  __assign,
  __awaiter,
  __generator,
  __read,
  __spreadArray,
  __values
} from "./chunk-OJGWAIVN.js";
import "./chunk-SNAQBZPT.js";

// node_modules/idb/lib/idb.mjs
function toArray(arr) {
  return Array.prototype.slice.call(arr);
}
function promisifyRequest(request) {
  return new Promise(function(resolve, reject) {
    request.onsuccess = function() {
      resolve(request.result);
    };
    request.onerror = function() {
      reject(request.error);
    };
  });
}
function promisifyRequestCall(obj, method, args) {
  var request;
  var p = new Promise(function(resolve, reject) {
    request = obj[method].apply(obj, args);
    promisifyRequest(request).then(resolve, reject);
  });
  p.request = request;
  return p;
}
function promisifyCursorRequestCall(obj, method, args) {
  var p = promisifyRequestCall(obj, method, args);
  return p.then(function(value) {
    if (!value) return;
    return new Cursor(value, p.request);
  });
}
function proxyProperties(ProxyClass, targetProp, properties) {
  properties.forEach(function(prop) {
    Object.defineProperty(ProxyClass.prototype, prop, {
      get: function() {
        return this[targetProp][prop];
      },
      set: function(val) {
        this[targetProp][prop] = val;
      }
    });
  });
}
function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype)) return;
    ProxyClass.prototype[prop] = function() {
      return promisifyRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype)) return;
    ProxyClass.prototype[prop] = function() {
      return this[targetProp][prop].apply(this[targetProp], arguments);
    };
  });
}
function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype)) return;
    ProxyClass.prototype[prop] = function() {
      return promisifyCursorRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function Index(index) {
  this._index = index;
}
proxyProperties(Index, "_index", [
  "name",
  "keyPath",
  "multiEntry",
  "unique"
]);
proxyRequestMethods(Index, "_index", IDBIndex, [
  "get",
  "getKey",
  "getAll",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(Index, "_index", IDBIndex, [
  "openCursor",
  "openKeyCursor"
]);
function Cursor(cursor, request) {
  this._cursor = cursor;
  this._request = request;
}
proxyProperties(Cursor, "_cursor", [
  "direction",
  "key",
  "primaryKey",
  "value"
]);
proxyRequestMethods(Cursor, "_cursor", IDBCursor, [
  "update",
  "delete"
]);
["advance", "continue", "continuePrimaryKey"].forEach(function(methodName) {
  if (!(methodName in IDBCursor.prototype)) return;
  Cursor.prototype[methodName] = function() {
    var cursor = this;
    var args = arguments;
    return Promise.resolve().then(function() {
      cursor._cursor[methodName].apply(cursor._cursor, args);
      return promisifyRequest(cursor._request).then(function(value) {
        if (!value) return;
        return new Cursor(value, cursor._request);
      });
    });
  };
});
function ObjectStore(store) {
  this._store = store;
}
ObjectStore.prototype.createIndex = function() {
  return new Index(this._store.createIndex.apply(this._store, arguments));
};
ObjectStore.prototype.index = function() {
  return new Index(this._store.index.apply(this._store, arguments));
};
proxyProperties(ObjectStore, "_store", [
  "name",
  "keyPath",
  "indexNames",
  "autoIncrement"
]);
proxyRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "put",
  "add",
  "delete",
  "clear",
  "get",
  "getAll",
  "getKey",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "openCursor",
  "openKeyCursor"
]);
proxyMethods(ObjectStore, "_store", IDBObjectStore, [
  "deleteIndex"
]);
function Transaction(idbTransaction) {
  this._tx = idbTransaction;
  this.complete = new Promise(function(resolve, reject) {
    idbTransaction.oncomplete = function() {
      resolve();
    };
    idbTransaction.onerror = function() {
      reject(idbTransaction.error);
    };
    idbTransaction.onabort = function() {
      reject(idbTransaction.error);
    };
  });
}
Transaction.prototype.objectStore = function() {
  return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
};
proxyProperties(Transaction, "_tx", [
  "objectStoreNames",
  "mode"
]);
proxyMethods(Transaction, "_tx", IDBTransaction, [
  "abort"
]);
function UpgradeDB(db, oldVersion, transaction) {
  this._db = db;
  this.oldVersion = oldVersion;
  this.transaction = new Transaction(transaction);
}
UpgradeDB.prototype.createObjectStore = function() {
  return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
};
proxyProperties(UpgradeDB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(UpgradeDB, "_db", IDBDatabase, [
  "deleteObjectStore",
  "close"
]);
function DB(db) {
  this._db = db;
}
DB.prototype.transaction = function() {
  return new Transaction(this._db.transaction.apply(this._db, arguments));
};
proxyProperties(DB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(DB, "_db", IDBDatabase, [
  "close"
]);
["openCursor", "openKeyCursor"].forEach(function(funcName) {
  [ObjectStore, Index].forEach(function(Constructor) {
    if (!(funcName in Constructor.prototype)) return;
    Constructor.prototype[funcName.replace("open", "iterate")] = function() {
      var args = toArray(arguments);
      var callback = args[args.length - 1];
      var nativeObject = this._store || this._index;
      var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
      request.onsuccess = function() {
        callback(request.result);
      };
    };
  });
});
[Index, ObjectStore].forEach(function(Constructor) {
  if (Constructor.prototype.getAll) return;
  Constructor.prototype.getAll = function(query, count) {
    var instance = this;
    var items = [];
    return new Promise(function(resolve) {
      instance.iterateCursor(query, function(cursor) {
        if (!cursor) {
          resolve(items);
          return;
        }
        items.push(cursor.value);
        if (count !== void 0 && items.length == count) {
          resolve(items);
          return;
        }
        cursor.continue();
      });
    });
  };
});
function openDb(name2, version2, upgradeCallback) {
  var p = promisifyRequestCall(indexedDB, "open", [name2, version2]);
  var request = p.request;
  if (request) {
    request.onupgradeneeded = function(event) {
      if (upgradeCallback) {
        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
      }
    };
  }
  return p.then(function(db) {
    return new DB(db);
  });
}
function deleteDb(name2) {
  return promisifyRequestCall(indexedDB, "deleteDatabase", [name2]);
}

// node_modules/@firebase/installations/dist/index.esm.js
var name = "@firebase/installations";
var version = "0.4.32";
var PENDING_TIMEOUT_MS = 1e4;
var PACKAGE_VERSION = "w:" + version;
var INTERNAL_AUTH_VERSION = "FIS_v2";
var INSTALLATIONS_API_URL = "https://firebaseinstallations.googleapis.com/v1";
var TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1e3;
var SERVICE = "installations";
var SERVICE_NAME = "Installations";
var _a;
var ERROR_DESCRIPTION_MAP = (_a = {}, _a[
  "missing-app-config-values"
  /* MISSING_APP_CONFIG_VALUES */
] = 'Missing App configuration value: "{$valueName}"', _a[
  "not-registered"
  /* NOT_REGISTERED */
] = "Firebase Installation is not registered.", _a[
  "installation-not-found"
  /* INSTALLATION_NOT_FOUND */
] = "Firebase Installation not found.", _a[
  "request-failed"
  /* REQUEST_FAILED */
] = '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"', _a[
  "app-offline"
  /* APP_OFFLINE */
] = "Could not process request. Application offline.", _a[
  "delete-pending-registration"
  /* DELETE_PENDING_REGISTRATION */
] = "Can't delete installation while there is a pending registration request.", _a);
var ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
function isServerError(error) {
  return error instanceof FirebaseError && error.code.includes(
    "request-failed"
    /* REQUEST_FAILED */
  );
}
function getInstallationsEndpoint(_a3) {
  var projectId = _a3.projectId;
  return INSTALLATIONS_API_URL + "/projects/" + projectId + "/installations";
}
function extractAuthTokenInfoFromResponse(response) {
  return {
    token: response.token,
    requestStatus: 2,
    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
    creationTime: Date.now()
  };
}
function getErrorFromResponse(requestName, response) {
  return __awaiter(this, void 0, void 0, function() {
    var responseJson, errorData;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, response.json()];
        case 1:
          responseJson = _a3.sent();
          errorData = responseJson.error;
          return [2, ERROR_FACTORY.create("request-failed", {
            requestName,
            serverCode: errorData.code,
            serverMessage: errorData.message,
            serverStatus: errorData.status
          })];
      }
    });
  });
}
function getHeaders(_a3) {
  var apiKey = _a3.apiKey;
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function getHeadersWithAuth(appConfig, _a3) {
  var refreshToken = _a3.refreshToken;
  var headers = getHeaders(appConfig);
  headers.append("Authorization", getAuthorizationHeader(refreshToken));
  return headers;
}
function retryIfServerError(fn) {
  return __awaiter(this, void 0, void 0, function() {
    var result;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, fn()];
        case 1:
          result = _a3.sent();
          if (result.status >= 500 && result.status < 600) {
            return [2, fn()];
          }
          return [2, result];
      }
    });
  });
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) {
  return Number(responseExpiresIn.replace("s", "000"));
}
function getAuthorizationHeader(refreshToken) {
  return INTERNAL_AUTH_VERSION + " " + refreshToken;
}
function createInstallationRequest(appConfig, _a3) {
  var fid = _a3.fid;
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, body, request, response, responseValue, registeredInstallationEntry;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          endpoint = getInstallationsEndpoint(appConfig);
          headers = getHeaders(appConfig);
          body = {
            fid,
            authVersion: INTERNAL_AUTH_VERSION,
            appId: appConfig.appId,
            sdkVersion: PACKAGE_VERSION
          };
          request = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _b.sent();
          if (!response.ok) return [3, 3];
          return [4, response.json()];
        case 2:
          responseValue = _b.sent();
          registeredInstallationEntry = {
            fid: responseValue.fid || fid,
            registrationStatus: 2,
            refreshToken: responseValue.refreshToken,
            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
          };
          return [2, registeredInstallationEntry];
        case 3:
          return [4, getErrorFromResponse("Create Installation", response)];
        case 4:
          throw _b.sent();
      }
    });
  });
}
function sleep(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}
function bufferToBase64UrlSafe(array) {
  var b64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(array))));
  return b64.replace(/\+/g, "-").replace(/\//g, "_");
}
var VALID_FID_PATTERN = /^[cdef][\w-]{21}$/;
var INVALID_FID = "";
function generateFid() {
  try {
    var fidByteArray = new Uint8Array(17);
    var crypto_1 = self.crypto || self.msCrypto;
    crypto_1.getRandomValues(fidByteArray);
    fidByteArray[0] = 112 + fidByteArray[0] % 16;
    var fid = encode(fidByteArray);
    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  } catch (_a3) {
    return INVALID_FID;
  }
}
function encode(fidByteArray) {
  var b64String = bufferToBase64UrlSafe(fidByteArray);
  return b64String.substr(0, 22);
}
function getKey(appConfig) {
  return appConfig.appName + "!" + appConfig.appId;
}
var fidChangeCallbacks = /* @__PURE__ */ new Map();
function fidChanged(appConfig, fid) {
  var key = getKey(appConfig);
  callFidChangeCallbacks(key, fid);
  broadcastFidChange(key, fid);
}
function addCallback(appConfig, callback) {
  getBroadcastChannel();
  var key = getKey(appConfig);
  var callbackSet = fidChangeCallbacks.get(key);
  if (!callbackSet) {
    callbackSet = /* @__PURE__ */ new Set();
    fidChangeCallbacks.set(key, callbackSet);
  }
  callbackSet.add(callback);
}
function removeCallback(appConfig, callback) {
  var key = getKey(appConfig);
  var callbackSet = fidChangeCallbacks.get(key);
  if (!callbackSet) {
    return;
  }
  callbackSet.delete(callback);
  if (callbackSet.size === 0) {
    fidChangeCallbacks.delete(key);
  }
  closeBroadcastChannel();
}
function callFidChangeCallbacks(key, fid) {
  var e_1, _a3;
  var callbacks = fidChangeCallbacks.get(key);
  if (!callbacks) {
    return;
  }
  try {
    for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
      var callback = callbacks_1_1.value;
      callback(fid);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (callbacks_1_1 && !callbacks_1_1.done && (_a3 = callbacks_1.return)) _a3.call(callbacks_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
}
function broadcastFidChange(key, fid) {
  var channel = getBroadcastChannel();
  if (channel) {
    channel.postMessage({ key, fid });
  }
  closeBroadcastChannel();
}
var broadcastChannel = null;
function getBroadcastChannel() {
  if (!broadcastChannel && "BroadcastChannel" in self) {
    broadcastChannel = new BroadcastChannel("[Firebase] FID Change");
    broadcastChannel.onmessage = function(e) {
      callFidChangeCallbacks(e.data.key, e.data.fid);
    };
  }
  return broadcastChannel;
}
function closeBroadcastChannel() {
  if (fidChangeCallbacks.size === 0 && broadcastChannel) {
    broadcastChannel.close();
    broadcastChannel = null;
  }
}
var DATABASE_NAME = "firebase-installations-database";
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = "firebase-installations-store";
var dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, function(upgradeDB) {
      switch (upgradeDB.oldVersion) {
        case 0:
          upgradeDB.createObjectStore(OBJECT_STORE_NAME);
      }
    });
  }
  return dbPromise;
}
function set(appConfig, value) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx, objectStore, oldValue;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a3.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          objectStore = tx.objectStore(OBJECT_STORE_NAME);
          return [4, objectStore.get(key)];
        case 2:
          oldValue = _a3.sent();
          return [4, objectStore.put(value, key)];
        case 3:
          _a3.sent();
          return [4, tx.complete];
        case 4:
          _a3.sent();
          if (!oldValue || oldValue.fid !== value.fid) {
            fidChanged(appConfig, value.fid);
          }
          return [2, value];
      }
    });
  });
}
function remove(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a3.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME).delete(key)];
        case 2:
          _a3.sent();
          return [4, tx.complete];
        case 3:
          _a3.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function update(appConfig, updateFn) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx, store, oldValue, newValue;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a3.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          store = tx.objectStore(OBJECT_STORE_NAME);
          return [4, store.get(key)];
        case 2:
          oldValue = _a3.sent();
          newValue = updateFn(oldValue);
          if (!(newValue === void 0)) return [3, 4];
          return [4, store.delete(key)];
        case 3:
          _a3.sent();
          return [3, 6];
        case 4:
          return [4, store.put(newValue, key)];
        case 5:
          _a3.sent();
          _a3.label = 6;
        case 6:
          return [4, tx.complete];
        case 7:
          _a3.sent();
          if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {
            fidChanged(appConfig, newValue.fid);
          }
          return [2, newValue];
      }
    });
  });
}
function getInstallationEntry(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var registrationPromise, installationEntry;
    var _a3;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, update(appConfig, function(oldEntry) {
            var installationEntry2 = updateOrCreateInstallationEntry(oldEntry);
            var entryWithPromise = triggerRegistrationIfNecessary(appConfig, installationEntry2);
            registrationPromise = entryWithPromise.registrationPromise;
            return entryWithPromise.installationEntry;
          })];
        case 1:
          installationEntry = _b.sent();
          if (!(installationEntry.fid === INVALID_FID)) return [3, 3];
          _a3 = {};
          return [4, registrationPromise];
        case 2:
          return [2, (_a3.installationEntry = _b.sent(), _a3)];
        case 3:
          return [2, {
            installationEntry,
            registrationPromise
          }];
      }
    });
  });
}
function updateOrCreateInstallationEntry(oldEntry) {
  var entry = oldEntry || {
    fid: generateFid(),
    registrationStatus: 0
    /* NOT_STARTED */
  };
  return clearTimedOutRequest(entry);
}
function triggerRegistrationIfNecessary(appConfig, installationEntry) {
  if (installationEntry.registrationStatus === 0) {
    if (!navigator.onLine) {
      var registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(
        "app-offline"
        /* APP_OFFLINE */
      ));
      return {
        installationEntry,
        registrationPromise: registrationPromiseWithError
      };
    }
    var inProgressEntry = {
      fid: installationEntry.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    };
    var registrationPromise = registerInstallation(appConfig, inProgressEntry);
    return { installationEntry: inProgressEntry, registrationPromise };
  } else if (installationEntry.registrationStatus === 1) {
    return {
      installationEntry,
      registrationPromise: waitUntilFidRegistration(appConfig)
    };
  } else {
    return { installationEntry };
  }
}
function registerInstallation(appConfig, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var registeredInstallationEntry, e_1;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          _a3.trys.push([0, 2, , 7]);
          return [4, createInstallationRequest(appConfig, installationEntry)];
        case 1:
          registeredInstallationEntry = _a3.sent();
          return [2, set(appConfig, registeredInstallationEntry)];
        case 2:
          e_1 = _a3.sent();
          if (!(isServerError(e_1) && e_1.customData.serverCode === 409)) return [3, 4];
          return [4, remove(appConfig)];
        case 3:
          _a3.sent();
          return [3, 6];
        case 4:
          return [4, set(appConfig, {
            fid: installationEntry.fid,
            registrationStatus: 0
            /* NOT_STARTED */
          })];
        case 5:
          _a3.sent();
          _a3.label = 6;
        case 6:
          throw e_1;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function waitUntilFidRegistration(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var entry, _a3, installationEntry, registrationPromise;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, updateInstallationRequest(appConfig)];
        case 1:
          entry = _b.sent();
          _b.label = 2;
        case 2:
          if (!(entry.registrationStatus === 1)) return [3, 5];
          return [4, sleep(100)];
        case 3:
          _b.sent();
          return [4, updateInstallationRequest(appConfig)];
        case 4:
          entry = _b.sent();
          return [3, 2];
        case 5:
          if (!(entry.registrationStatus === 0)) return [3, 7];
          return [4, getInstallationEntry(appConfig)];
        case 6:
          _a3 = _b.sent(), installationEntry = _a3.installationEntry, registrationPromise = _a3.registrationPromise;
          if (registrationPromise) {
            return [2, registrationPromise];
          } else {
            return [2, installationEntry];
          }
        case 7:
          return [2, entry];
      }
    });
  });
}
function updateInstallationRequest(appConfig) {
  return update(appConfig, function(oldEntry) {
    if (!oldEntry) {
      throw ERROR_FACTORY.create(
        "installation-not-found"
        /* INSTALLATION_NOT_FOUND */
      );
    }
    return clearTimedOutRequest(oldEntry);
  });
}
function clearTimedOutRequest(entry) {
  if (hasInstallationRequestTimedOut(entry)) {
    return {
      fid: entry.fid,
      registrationStatus: 0
      /* NOT_STARTED */
    };
  }
  return entry;
}
function hasInstallationRequestTimedOut(installationEntry) {
  return installationEntry.registrationStatus === 1 && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();
}
function generateAuthTokenRequest(_a3, installationEntry) {
  var appConfig = _a3.appConfig, platformLoggerProvider = _a3.platformLoggerProvider;
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, platformLogger, body, request, response, responseValue, completedAuthToken;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
          headers = getHeadersWithAuth(appConfig, installationEntry);
          platformLogger = platformLoggerProvider.getImmediate({
            optional: true
          });
          if (platformLogger) {
            headers.append("x-firebase-client", platformLogger.getPlatformInfoString());
          }
          body = {
            installation: {
              sdkVersion: PACKAGE_VERSION
            }
          };
          request = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _b.sent();
          if (!response.ok) return [3, 3];
          return [4, response.json()];
        case 2:
          responseValue = _b.sent();
          completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
          return [2, completedAuthToken];
        case 3:
          return [4, getErrorFromResponse("Generate Auth Token", response)];
        case 4:
          throw _b.sent();
      }
    });
  });
}
function getGenerateAuthTokenEndpoint(appConfig, _a3) {
  var fid = _a3.fid;
  return getInstallationsEndpoint(appConfig) + "/" + fid + "/authTokens:generate";
}
function refreshAuthToken(dependencies, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var tokenPromise, entry, authToken, _a3;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, update(dependencies.appConfig, function(oldEntry) {
            if (!isEntryRegistered(oldEntry)) {
              throw ERROR_FACTORY.create(
                "not-registered"
                /* NOT_REGISTERED */
              );
            }
            var oldAuthToken = oldEntry.authToken;
            if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {
              return oldEntry;
            } else if (oldAuthToken.requestStatus === 1) {
              tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);
              return oldEntry;
            } else {
              if (!navigator.onLine) {
                throw ERROR_FACTORY.create(
                  "app-offline"
                  /* APP_OFFLINE */
                );
              }
              var inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
              tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);
              return inProgressEntry;
            }
          })];
        case 1:
          entry = _b.sent();
          if (!tokenPromise) return [3, 3];
          return [4, tokenPromise];
        case 2:
          _a3 = _b.sent();
          return [3, 4];
        case 3:
          _a3 = entry.authToken;
          _b.label = 4;
        case 4:
          authToken = _a3;
          return [2, authToken];
      }
    });
  });
}
function waitUntilAuthTokenRequest(dependencies, forceRefresh) {
  return __awaiter(this, void 0, void 0, function() {
    var entry, authToken;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, updateAuthTokenRequest(dependencies.appConfig)];
        case 1:
          entry = _a3.sent();
          _a3.label = 2;
        case 2:
          if (!(entry.authToken.requestStatus === 1)) return [3, 5];
          return [4, sleep(100)];
        case 3:
          _a3.sent();
          return [4, updateAuthTokenRequest(dependencies.appConfig)];
        case 4:
          entry = _a3.sent();
          return [3, 2];
        case 5:
          authToken = entry.authToken;
          if (authToken.requestStatus === 0) {
            return [2, refreshAuthToken(dependencies, forceRefresh)];
          } else {
            return [2, authToken];
          }
      }
    });
  });
}
function updateAuthTokenRequest(appConfig) {
  return update(appConfig, function(oldEntry) {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY.create(
        "not-registered"
        /* NOT_REGISTERED */
      );
    }
    var oldAuthToken = oldEntry.authToken;
    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {
      return __assign(__assign({}, oldEntry), { authToken: {
        requestStatus: 0
        /* NOT_STARTED */
      } });
    }
    return oldEntry;
  });
}
function fetchAuthTokenFromServer(dependencies, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, updatedInstallationEntry, e_1, updatedInstallationEntry;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          _a3.trys.push([0, 3, , 8]);
          return [4, generateAuthTokenRequest(dependencies, installationEntry)];
        case 1:
          authToken = _a3.sent();
          updatedInstallationEntry = __assign(__assign({}, installationEntry), { authToken });
          return [4, set(dependencies.appConfig, updatedInstallationEntry)];
        case 2:
          _a3.sent();
          return [2, authToken];
        case 3:
          e_1 = _a3.sent();
          if (!(isServerError(e_1) && (e_1.customData.serverCode === 401 || e_1.customData.serverCode === 404))) return [3, 5];
          return [4, remove(dependencies.appConfig)];
        case 4:
          _a3.sent();
          return [3, 7];
        case 5:
          updatedInstallationEntry = __assign(__assign({}, installationEntry), { authToken: {
            requestStatus: 0
            /* NOT_STARTED */
          } });
          return [4, set(dependencies.appConfig, updatedInstallationEntry)];
        case 6:
          _a3.sent();
          _a3.label = 7;
        case 7:
          throw e_1;
        case 8:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function isEntryRegistered(installationEntry) {
  return installationEntry !== void 0 && installationEntry.registrationStatus === 2;
}
function isAuthTokenValid(authToken) {
  return authToken.requestStatus === 2 && !isAuthTokenExpired(authToken);
}
function isAuthTokenExpired(authToken) {
  var now = Date.now();
  return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;
}
function makeAuthTokenRequestInProgressEntry(oldEntry) {
  var inProgressAuthToken = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return __assign(__assign({}, oldEntry), { authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) {
  return authToken.requestStatus === 1 && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();
}
function getId(dependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var _a3, installationEntry, registrationPromise;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, getInstallationEntry(dependencies.appConfig)];
        case 1:
          _a3 = _b.sent(), installationEntry = _a3.installationEntry, registrationPromise = _a3.registrationPromise;
          if (registrationPromise) {
            registrationPromise.catch(console.error);
          } else {
            refreshAuthToken(dependencies).catch(console.error);
          }
          return [2, installationEntry.fid];
      }
    });
  });
}
function getToken(dependencies, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var authToken;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, completeInstallationRegistration(dependencies.appConfig)];
        case 1:
          _a3.sent();
          return [4, refreshAuthToken(dependencies, forceRefresh)];
        case 2:
          authToken = _a3.sent();
          return [2, authToken.token];
      }
    });
  });
}
function completeInstallationRegistration(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var registrationPromise;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, getInstallationEntry(appConfig)];
        case 1:
          registrationPromise = _a3.sent().registrationPromise;
          if (!registrationPromise) return [3, 3];
          return [4, registrationPromise];
        case 2:
          _a3.sent();
          _a3.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function deleteInstallationRequest(appConfig, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, request, response;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          endpoint = getDeleteEndpoint(appConfig, installationEntry);
          headers = getHeadersWithAuth(appConfig, installationEntry);
          request = {
            method: "DELETE",
            headers
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _a3.sent();
          if (!!response.ok) return [3, 3];
          return [4, getErrorFromResponse("Delete Installation", response)];
        case 2:
          throw _a3.sent();
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getDeleteEndpoint(appConfig, _a3) {
  var fid = _a3.fid;
  return getInstallationsEndpoint(appConfig) + "/" + fid;
}
function deleteInstallation(dependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var appConfig, entry;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          appConfig = dependencies.appConfig;
          return [4, update(appConfig, function(oldEntry) {
            if (oldEntry && oldEntry.registrationStatus === 0) {
              return void 0;
            }
            return oldEntry;
          })];
        case 1:
          entry = _a3.sent();
          if (!entry) return [3, 6];
          if (!(entry.registrationStatus === 1)) return [3, 2];
          throw ERROR_FACTORY.create(
            "delete-pending-registration"
            /* DELETE_PENDING_REGISTRATION */
          );
        case 2:
          if (!(entry.registrationStatus === 2)) return [3, 6];
          if (!!navigator.onLine) return [3, 3];
          throw ERROR_FACTORY.create(
            "app-offline"
            /* APP_OFFLINE */
          );
        case 3:
          return [4, deleteInstallationRequest(appConfig, entry)];
        case 4:
          _a3.sent();
          return [4, remove(appConfig)];
        case 5:
          _a3.sent();
          _a3.label = 6;
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function onIdChange(_a3, callback) {
  var appConfig = _a3.appConfig;
  addCallback(appConfig, callback);
  return function() {
    removeCallback(appConfig, callback);
  };
}
function extractAppConfig(app) {
  var e_1, _a3;
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  var configKeys = [
    "projectId",
    "apiKey",
    "appId"
  ];
  try {
    for (var configKeys_1 = __values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {
      var keyName = configKeys_1_1.value;
      if (!app.options[keyName]) {
        throw getMissingValueError(keyName);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (configKeys_1_1 && !configKeys_1_1.done && (_a3 = configKeys_1.return)) _a3.call(configKeys_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return {
    appName: app.name,
    projectId: app.options.projectId,
    apiKey: app.options.apiKey,
    appId: app.options.appId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY.create("missing-app-config-values", {
    valueName
  });
}
function registerInstallations(instance) {
  var installationsName = "installations";
  instance.INTERNAL.registerComponent(new Component(
    installationsName,
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var appConfig = extractAppConfig(app);
      var platformLoggerProvider = container.getProvider("platform-logger");
      var dependencies = {
        appConfig,
        platformLoggerProvider
      };
      var installations = {
        app,
        getId: function() {
          return getId(dependencies);
        },
        getToken: function(forceRefresh) {
          return getToken(dependencies, forceRefresh);
        },
        delete: function() {
          return deleteInstallation(dependencies);
        },
        onIdChange: function(callback) {
          return onIdChange(dependencies, callback);
        }
      };
      return installations;
    },
    "PUBLIC"
    /* PUBLIC */
  ));
  instance.registerVersion(name, version);
}
registerInstallations(index_esm_default);

// node_modules/@firebase/messaging/dist/index.esm.js
var _a2;
var ERROR_MAP = (_a2 = {}, _a2[
  "missing-app-config-values"
  /* MISSING_APP_CONFIG_VALUES */
] = 'Missing App configuration value: "{$valueName}"', _a2[
  "only-available-in-window"
  /* AVAILABLE_IN_WINDOW */
] = "This method is available in a Window context.", _a2[
  "only-available-in-sw"
  /* AVAILABLE_IN_SW */
] = "This method is available in a service worker context.", _a2[
  "permission-default"
  /* PERMISSION_DEFAULT */
] = "The notification permission was not granted and dismissed instead.", _a2[
  "permission-blocked"
  /* PERMISSION_BLOCKED */
] = "The notification permission was not granted and blocked instead.", _a2[
  "unsupported-browser"
  /* UNSUPPORTED_BROWSER */
] = "This browser doesn't support the API's required to use the firebase SDK.", _a2[
  "failed-service-worker-registration"
  /* FAILED_DEFAULT_REGISTRATION */
] = "We are unable to register the default service worker. {$browserErrorMessage}", _a2[
  "token-subscribe-failed"
  /* TOKEN_SUBSCRIBE_FAILED */
] = "A problem occurred while subscribing the user to FCM: {$errorInfo}", _a2[
  "token-subscribe-no-token"
  /* TOKEN_SUBSCRIBE_NO_TOKEN */
] = "FCM returned no token when subscribing the user to push.", _a2[
  "token-unsubscribe-failed"
  /* TOKEN_UNSUBSCRIBE_FAILED */
] = "A problem occurred while unsubscribing the user from FCM: {$errorInfo}", _a2[
  "token-update-failed"
  /* TOKEN_UPDATE_FAILED */
] = "A problem occurred while updating the user from FCM: {$errorInfo}", _a2[
  "token-update-no-token"
  /* TOKEN_UPDATE_NO_TOKEN */
] = "FCM returned no token when updating the user to push.", _a2[
  "use-sw-after-get-token"
  /* USE_SW_AFTER_GET_TOKEN */
] = "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.", _a2[
  "invalid-sw-registration"
  /* INVALID_SW_REGISTRATION */
] = "The input to useServiceWorker() must be a ServiceWorkerRegistration.", _a2[
  "invalid-bg-handler"
  /* INVALID_BG_HANDLER */
] = "The input to setBackgroundMessageHandler() must be a function.", _a2[
  "invalid-vapid-key"
  /* INVALID_VAPID_KEY */
] = "The public VAPID key must be a string.", _a2[
  "use-vapid-key-after-get-token"
  /* USE_VAPID_KEY_AFTER_GET_TOKEN */
] = "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used.", _a2);
var ERROR_FACTORY2 = new ErrorFactory("messaging", "Messaging", ERROR_MAP);
var DEFAULT_SW_PATH = "/firebase-messaging-sw.js";
var DEFAULT_SW_SCOPE = "/firebase-cloud-messaging-push-scope";
var DEFAULT_VAPID_KEY = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4";
var ENDPOINT = "https://fcmregistrations.googleapis.com/v1";
var FCM_MSG = "FCM_MSG";
var TAG = "FirebaseMessaging: ";
var CONSOLE_CAMPAIGN_ANALYTICS_ENABLED = "google.c.a.e";
var CONSOLE_CAMPAIGN_ID = "google.c.a.c_id";
var CONSOLE_CAMPAIGN_TIME = "google.c.a.ts";
var CONSOLE_CAMPAIGN_NAME = "google.c.a.c_l";
var BACKGROUND_HANDLE_EXECUTION_TIME_LIMIT_MS = 1e3;
var FOREGROUND_HANDLE_PREPARATION_TIME_MS = 3e3;
var MessageType;
(function(MessageType2) {
  MessageType2["PUSH_RECEIVED"] = "push-received";
  MessageType2["NOTIFICATION_CLICKED"] = "notification-clicked";
})(MessageType || (MessageType = {}));
function arrayToBase64(array) {
  var uint8Array = new Uint8Array(array);
  var base64String = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(uint8Array))));
  return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64ToArray(base64String) {
  var padding = "=".repeat((4 - base64String.length % 4) % 4);
  var base64 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
  var rawData = atob(base64);
  var outputArray = new Uint8Array(rawData.length);
  for (var i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
var OLD_DB_NAME = "fcm_token_details_db";
var OLD_DB_VERSION = 5;
var OLD_OBJECT_STORE_NAME = "fcm_token_object_Store";
function migrateOldDatabase(senderId) {
  return __awaiter(this, void 0, void 0, function() {
    var databases, dbNames, tokenDetails, db;
    var _this = this;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          if (!("databases" in indexedDB)) return [3, 2];
          return [4, indexedDB.databases()];
        case 1:
          databases = _a3.sent();
          dbNames = databases.map(function(db2) {
            return db2.name;
          });
          if (!dbNames.includes(OLD_DB_NAME)) {
            return [2, null];
          }
          _a3.label = 2;
        case 2:
          tokenDetails = null;
          return [4, openDb(OLD_DB_NAME, OLD_DB_VERSION, function(db2) {
            return __awaiter(_this, void 0, void 0, function() {
              var objectStore, value, oldDetails, oldDetails, oldDetails;
              var _a4;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    if (db2.oldVersion < 2) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    if (!db2.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    objectStore = db2.transaction.objectStore(OLD_OBJECT_STORE_NAME);
                    return [4, objectStore.index("fcmSenderId").get(senderId)];
                  case 1:
                    value = _b.sent();
                    return [4, objectStore.clear()];
                  case 2:
                    _b.sent();
                    if (!value) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    if (db2.oldVersion === 2) {
                      oldDetails = value;
                      if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {
                        return [
                          2
                          /*return*/
                        ];
                      }
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: (_a4 = oldDetails.createTime) !== null && _a4 !== void 0 ? _a4 : Date.now(),
                        subscriptionOptions: {
                          auth: oldDetails.auth,
                          p256dh: oldDetails.p256dh,
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: typeof oldDetails.vapidKey === "string" ? oldDetails.vapidKey : arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    } else if (db2.oldVersion === 3) {
                      oldDetails = value;
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: oldDetails.createTime,
                        subscriptionOptions: {
                          auth: arrayToBase64(oldDetails.auth),
                          p256dh: arrayToBase64(oldDetails.p256dh),
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    } else if (db2.oldVersion === 4) {
                      oldDetails = value;
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: oldDetails.createTime,
                        subscriptionOptions: {
                          auth: arrayToBase64(oldDetails.auth),
                          p256dh: arrayToBase64(oldDetails.p256dh),
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    }
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          })];
        case 3:
          db = _a3.sent();
          db.close();
          return [4, deleteDb(OLD_DB_NAME)];
        case 4:
          _a3.sent();
          return [4, deleteDb("fcm_vapid_details_db")];
        case 5:
          _a3.sent();
          return [4, deleteDb("undefined")];
        case 6:
          _a3.sent();
          return [2, checkTokenDetails(tokenDetails) ? tokenDetails : null];
      }
    });
  });
}
function checkTokenDetails(tokenDetails) {
  if (!tokenDetails || !tokenDetails.subscriptionOptions) {
    return false;
  }
  var subscriptionOptions = tokenDetails.subscriptionOptions;
  return typeof tokenDetails.createTime === "number" && tokenDetails.createTime > 0 && typeof tokenDetails.token === "string" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === "string" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === "string" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === "string" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === "string" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === "string" && subscriptionOptions.vapidKey.length > 0;
}
var DATABASE_NAME2 = "firebase-messaging-database";
var DATABASE_VERSION2 = 1;
var OBJECT_STORE_NAME2 = "firebase-messaging-store";
var dbPromise2 = null;
function getDbPromise2() {
  if (!dbPromise2) {
    dbPromise2 = openDb(DATABASE_NAME2, DATABASE_VERSION2, function(upgradeDb) {
      switch (upgradeDb.oldVersion) {
        case 0:
          upgradeDb.createObjectStore(OBJECT_STORE_NAME2);
      }
    });
  }
  return dbPromise2;
}
function dbGet(firebaseDependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tokenDetails, oldTokenDetails;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db = _a3.sent();
          return [4, db.transaction(OBJECT_STORE_NAME2).objectStore(OBJECT_STORE_NAME2).get(key)];
        case 2:
          tokenDetails = _a3.sent();
          if (!tokenDetails) return [3, 3];
          return [2, tokenDetails];
        case 3:
          return [4, migrateOldDatabase(firebaseDependencies.appConfig.senderId)];
        case 4:
          oldTokenDetails = _a3.sent();
          if (!oldTokenDetails) return [3, 6];
          return [4, dbSet(firebaseDependencies, oldTokenDetails)];
        case 5:
          _a3.sent();
          return [2, oldTokenDetails];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function dbSet(firebaseDependencies, tokenDetails) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db = _a3.sent();
          tx = db.transaction(OBJECT_STORE_NAME2, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME2).put(tokenDetails, key)];
        case 2:
          _a3.sent();
          return [4, tx.complete];
        case 3:
          _a3.sent();
          return [2, tokenDetails];
      }
    });
  });
}
function dbRemove(firebaseDependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db = _a3.sent();
          tx = db.transaction(OBJECT_STORE_NAME2, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME2).delete(key)];
        case 2:
          _a3.sent();
          return [4, tx.complete];
        case 3:
          _a3.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getKey2(_a3) {
  var appConfig = _a3.appConfig;
  return appConfig.appId;
}
function requestGetToken(firebaseDependencies, subscriptionOptions) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, body, subscribeOptions, responseData, response, err_1, message;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a3.sent();
          body = getBody(subscriptionOptions);
          subscribeOptions = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          _a3.label = 2;
        case 2:
          _a3.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig), subscribeOptions)];
        case 3:
          response = _a3.sent();
          return [4, response.json()];
        case 4:
          responseData = _a3.sent();
          return [3, 6];
        case 5:
          err_1 = _a3.sent();
          throw ERROR_FACTORY2.create("token-subscribe-failed", {
            errorInfo: err_1
          });
        case 6:
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY2.create("token-subscribe-failed", {
              errorInfo: message
            });
          }
          if (!responseData.token) {
            throw ERROR_FACTORY2.create(
              "token-subscribe-no-token"
              /* TOKEN_SUBSCRIBE_NO_TOKEN */
            );
          }
          return [2, responseData.token];
      }
    });
  });
}
function requestUpdateToken(firebaseDependencies, tokenDetails) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, body, updateOptions, responseData, response, err_2, message;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a3.sent();
          body = getBody(tokenDetails.subscriptionOptions);
          updateOptions = {
            method: "PATCH",
            headers,
            body: JSON.stringify(body)
          };
          _a3.label = 2;
        case 2:
          _a3.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig) + "/" + tokenDetails.token, updateOptions)];
        case 3:
          response = _a3.sent();
          return [4, response.json()];
        case 4:
          responseData = _a3.sent();
          return [3, 6];
        case 5:
          err_2 = _a3.sent();
          throw ERROR_FACTORY2.create("token-update-failed", {
            errorInfo: err_2
          });
        case 6:
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY2.create("token-update-failed", {
              errorInfo: message
            });
          }
          if (!responseData.token) {
            throw ERROR_FACTORY2.create(
              "token-update-no-token"
              /* TOKEN_UPDATE_NO_TOKEN */
            );
          }
          return [2, responseData.token];
      }
    });
  });
}
function requestDeleteToken(firebaseDependencies, token) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, unsubscribeOptions, response, responseData, message, err_3;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a3.sent();
          unsubscribeOptions = {
            method: "DELETE",
            headers
          };
          _a3.label = 2;
        case 2:
          _a3.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig) + "/" + token, unsubscribeOptions)];
        case 3:
          response = _a3.sent();
          return [4, response.json()];
        case 4:
          responseData = _a3.sent();
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY2.create("token-unsubscribe-failed", {
              errorInfo: message
            });
          }
          return [3, 6];
        case 5:
          err_3 = _a3.sent();
          throw ERROR_FACTORY2.create("token-unsubscribe-failed", {
            errorInfo: err_3
          });
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getEndpoint(_a3) {
  var projectId = _a3.projectId;
  return ENDPOINT + "/projects/" + projectId + "/registrations";
}
function getHeaders2(_a3) {
  var appConfig = _a3.appConfig, installations = _a3.installations;
  return __awaiter(this, void 0, void 0, function() {
    var authToken;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, installations.getToken()];
        case 1:
          authToken = _b.sent();
          return [2, new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-goog-api-key": appConfig.apiKey,
            "x-goog-firebase-installations-auth": "FIS " + authToken
          })];
      }
    });
  });
}
function getBody(_a3) {
  var p256dh = _a3.p256dh, auth = _a3.auth, endpoint = _a3.endpoint, vapidKey = _a3.vapidKey;
  var body = {
    web: {
      endpoint,
      auth,
      p256dh
    }
  };
  if (vapidKey !== DEFAULT_VAPID_KEY) {
    body.web.applicationPubKey = vapidKey;
  }
  return body;
}
var TOKEN_EXPIRATION_MS = 7 * 24 * 60 * 60 * 1e3;
function getToken2(firebaseDependencies, swRegistration, vapidKey) {
  return __awaiter(this, void 0, void 0, function() {
    var pushSubscription, tokenDetails, subscriptionOptions, e_1;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          if (Notification.permission !== "granted") {
            throw ERROR_FACTORY2.create(
              "permission-blocked"
              /* PERMISSION_BLOCKED */
            );
          }
          return [4, getPushSubscription(swRegistration, vapidKey)];
        case 1:
          pushSubscription = _a3.sent();
          return [4, dbGet(firebaseDependencies)];
        case 2:
          tokenDetails = _a3.sent();
          subscriptionOptions = {
            vapidKey,
            swScope: swRegistration.scope,
            endpoint: pushSubscription.endpoint,
            auth: arrayToBase64(pushSubscription.getKey("auth")),
            p256dh: arrayToBase64(pushSubscription.getKey("p256dh"))
          };
          if (!!tokenDetails) return [3, 3];
          return [2, getNewToken(firebaseDependencies, subscriptionOptions)];
        case 3:
          if (!!isTokenValid(tokenDetails.subscriptionOptions, subscriptionOptions)) return [3, 8];
          _a3.label = 4;
        case 4:
          _a3.trys.push([4, 6, , 7]);
          return [4, requestDeleteToken(firebaseDependencies, tokenDetails.token)];
        case 5:
          _a3.sent();
          return [3, 7];
        case 6:
          e_1 = _a3.sent();
          console.warn(e_1);
          return [3, 7];
        case 7:
          return [2, getNewToken(firebaseDependencies, subscriptionOptions)];
        case 8:
          if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS) {
            return [2, updateToken({
              token: tokenDetails.token,
              createTime: Date.now(),
              subscriptionOptions
            }, firebaseDependencies, swRegistration)];
          } else {
            return [2, tokenDetails.token];
          }
        case 9:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function deleteToken(firebaseDependencies, swRegistration) {
  return __awaiter(this, void 0, void 0, function() {
    var tokenDetails, pushSubscription;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, dbGet(firebaseDependencies)];
        case 1:
          tokenDetails = _a3.sent();
          if (!tokenDetails) return [3, 4];
          return [4, requestDeleteToken(firebaseDependencies, tokenDetails.token)];
        case 2:
          _a3.sent();
          return [4, dbRemove(firebaseDependencies)];
        case 3:
          _a3.sent();
          _a3.label = 4;
        case 4:
          return [4, swRegistration.pushManager.getSubscription()];
        case 5:
          pushSubscription = _a3.sent();
          if (pushSubscription) {
            return [2, pushSubscription.unsubscribe()];
          }
          return [2, true];
      }
    });
  });
}
function updateToken(tokenDetails, firebaseDependencies, swRegistration) {
  return __awaiter(this, void 0, void 0, function() {
    var updatedToken, updatedTokenDetails, e_2;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          _a3.trys.push([0, 3, , 5]);
          return [4, requestUpdateToken(firebaseDependencies, tokenDetails)];
        case 1:
          updatedToken = _a3.sent();
          updatedTokenDetails = __assign(__assign({}, tokenDetails), { token: updatedToken, createTime: Date.now() });
          return [4, dbSet(firebaseDependencies, updatedTokenDetails)];
        case 2:
          _a3.sent();
          return [2, updatedToken];
        case 3:
          e_2 = _a3.sent();
          return [4, deleteToken(firebaseDependencies, swRegistration)];
        case 4:
          _a3.sent();
          throw e_2;
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getNewToken(firebaseDependencies, subscriptionOptions) {
  return __awaiter(this, void 0, void 0, function() {
    var token, tokenDetails;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, requestGetToken(firebaseDependencies, subscriptionOptions)];
        case 1:
          token = _a3.sent();
          tokenDetails = {
            token,
            createTime: Date.now(),
            subscriptionOptions
          };
          return [4, dbSet(firebaseDependencies, tokenDetails)];
        case 2:
          _a3.sent();
          return [2, tokenDetails.token];
      }
    });
  });
}
function getPushSubscription(swRegistration, vapidKey) {
  return __awaiter(this, void 0, void 0, function() {
    var subscription;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, swRegistration.pushManager.getSubscription()];
        case 1:
          subscription = _a3.sent();
          if (subscription) {
            return [2, subscription];
          }
          return [2, swRegistration.pushManager.subscribe({
            userVisibleOnly: true,
            // Chrome <= 75 doesn't support base64-encoded VAPID key. For backward compatibility, VAPID key
            // submitted to pushManager#subscribe must be of type Uint8Array.
            applicationServerKey: base64ToArray(vapidKey)
          })];
      }
    });
  });
}
function isTokenValid(dbOptions, currentOptions) {
  var isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;
  var isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;
  var isAuthEqual = currentOptions.auth === dbOptions.auth;
  var isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;
  return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;
}
function externalizePayload(internalPayload) {
  var payload = {
    from: internalPayload.from,
    // eslint-disable-next-line camelcase
    collapseKey: internalPayload.collapse_key,
    // eslint-disable-next-line camelcase
    messageId: internalPayload.fcm_message_id
  };
  propagateNotificationPayload(payload, internalPayload);
  propagateDataPayload(payload, internalPayload);
  propagateFcmOptions(payload, internalPayload);
  return payload;
}
function propagateNotificationPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.notification) {
    return;
  }
  payload.notification = {};
  var title = messagePayloadInternal.notification.title;
  if (!!title) {
    payload.notification.title = title;
  }
  var body = messagePayloadInternal.notification.body;
  if (!!body) {
    payload.notification.body = body;
  }
  var image = messagePayloadInternal.notification.image;
  if (!!image) {
    payload.notification.image = image;
  }
}
function propagateDataPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.data) {
    return;
  }
  payload.data = messagePayloadInternal.data;
}
function propagateFcmOptions(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.fcmOptions) {
    return;
  }
  payload.fcmOptions = {};
  var link = messagePayloadInternal.fcmOptions.link;
  if (!!link) {
    payload.fcmOptions.link = link;
  }
  var analyticsLabel = messagePayloadInternal.fcmOptions.analytics_label;
  if (!!analyticsLabel) {
    payload.fcmOptions.analyticsLabel = analyticsLabel;
  }
}
function isConsoleMessage(data) {
  return typeof data === "object" && !!data && CONSOLE_CAMPAIGN_ID in data;
}
function sleep2(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}
var SwController = (
  /** @class */
  function() {
    function SwController2(firebaseDependencies) {
      var _this = this;
      this.firebaseDependencies = firebaseDependencies;
      this.isOnBackgroundMessageUsed = null;
      this.vapidKey = null;
      this.bgMessageHandler = null;
      self.addEventListener("push", function(e) {
        e.waitUntil(_this.onPush(e));
      });
      self.addEventListener("pushsubscriptionchange", function(e) {
        e.waitUntil(_this.onSubChange(e));
      });
      self.addEventListener("notificationclick", function(e) {
        e.waitUntil(_this.onNotificationClick(e));
      });
    }
    Object.defineProperty(SwController2.prototype, "app", {
      get: function() {
        return this.firebaseDependencies.app;
      },
      enumerable: false,
      configurable: true
    });
    SwController2.prototype.setBackgroundMessageHandler = function(callback) {
      this.isOnBackgroundMessageUsed = false;
      if (!callback || typeof callback !== "function") {
        throw ERROR_FACTORY2.create(
          "invalid-bg-handler"
          /* INVALID_BG_HANDLER */
        );
      }
      this.bgMessageHandler = callback;
    };
    SwController2.prototype.onBackgroundMessage = function(nextOrObserver) {
      var _this = this;
      this.isOnBackgroundMessageUsed = true;
      this.bgMessageHandler = nextOrObserver;
      return function() {
        _this.bgMessageHandler = null;
      };
    };
    SwController2.prototype.getToken = function() {
      var _a3, _b;
      return __awaiter(this, void 0, void 0, function() {
        var tokenDetails;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              if (!!this.vapidKey) return [3, 2];
              return [4, dbGet(this.firebaseDependencies)];
            case 1:
              tokenDetails = _c.sent();
              this.vapidKey = (_b = (_a3 = tokenDetails === null || tokenDetails === void 0 ? void 0 : tokenDetails.subscriptionOptions) === null || _a3 === void 0 ? void 0 : _a3.vapidKey) !== null && _b !== void 0 ? _b : DEFAULT_VAPID_KEY;
              _c.label = 2;
            case 2:
              return [2, getToken2(this.firebaseDependencies, self.registration, this.vapidKey)];
          }
        });
      });
    };
    SwController2.prototype.deleteToken = function() {
      return deleteToken(this.firebaseDependencies, self.registration);
    };
    SwController2.prototype.requestPermission = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.usePublicVapidKey = function(vapidKey) {
      if (this.vapidKey !== null) {
        throw ERROR_FACTORY2.create(
          "use-vapid-key-after-get-token"
          /* USE_VAPID_KEY_AFTER_GET_TOKEN */
        );
      }
      if (typeof vapidKey !== "string" || vapidKey.length === 0) {
        throw ERROR_FACTORY2.create(
          "invalid-vapid-key"
          /* INVALID_VAPID_KEY */
        );
      }
      this.vapidKey = vapidKey;
    };
    SwController2.prototype.useServiceWorker = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onMessage = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onTokenRefresh = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onPush = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, clientList, isNotificationShown, payload;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              internalPayload = getMessagePayloadInternal(event);
              if (!internalPayload) {
                console.debug(TAG + "failed to get parsed MessagePayload from the PushEvent. Skip handling the push.");
                return [
                  2
                  /*return*/
                ];
              }
              return [4, getClientList()];
            case 1:
              clientList = _a3.sent();
              if (hasVisibleClients(clientList)) {
                return [2, sendMessagePayloadInternalToWindows(clientList, internalPayload)];
              }
              isNotificationShown = false;
              if (!!!internalPayload.notification) return [3, 3];
              return [4, showNotification(wrapInternalPayload(internalPayload))];
            case 2:
              _a3.sent();
              isNotificationShown = true;
              _a3.label = 3;
            case 3:
              if (isNotificationShown === true && this.isOnBackgroundMessageUsed === false) {
                return [
                  2
                  /*return*/
                ];
              }
              if (!!this.bgMessageHandler) {
                payload = externalizePayload(internalPayload);
                if (typeof this.bgMessageHandler === "function") {
                  this.bgMessageHandler(payload);
                } else {
                  this.bgMessageHandler.next(payload);
                }
              }
              return [4, sleep2(BACKGROUND_HANDLE_EXECUTION_TIME_LIMIT_MS)];
            case 4:
              _a3.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    SwController2.prototype.onSubChange = function(event) {
      var _a3, _b;
      return __awaiter(this, void 0, void 0, function() {
        var newSubscription, tokenDetails;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              newSubscription = event.newSubscription;
              if (!!newSubscription) return [3, 2];
              return [4, deleteToken(this.firebaseDependencies, self.registration)];
            case 1:
              _c.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              return [4, dbGet(this.firebaseDependencies)];
            case 3:
              tokenDetails = _c.sent();
              return [4, deleteToken(this.firebaseDependencies, self.registration)];
            case 4:
              _c.sent();
              return [4, getToken2(this.firebaseDependencies, self.registration, (_b = (_a3 = tokenDetails === null || tokenDetails === void 0 ? void 0 : tokenDetails.subscriptionOptions) === null || _a3 === void 0 ? void 0 : _a3.vapidKey) !== null && _b !== void 0 ? _b : DEFAULT_VAPID_KEY)];
            case 5:
              _c.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    SwController2.prototype.onNotificationClick = function(event) {
      var _a3, _b;
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, link, url, originUrl, client;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              internalPayload = (_b = (_a3 = event.notification) === null || _a3 === void 0 ? void 0 : _a3.data) === null || _b === void 0 ? void 0 : _b[FCM_MSG];
              if (!internalPayload) {
                return [
                  2
                  /*return*/
                ];
              } else if (event.action) {
                return [
                  2
                  /*return*/
                ];
              }
              event.stopImmediatePropagation();
              event.notification.close();
              link = getLink(internalPayload);
              if (!link) {
                return [
                  2
                  /*return*/
                ];
              }
              url = new URL(link, self.location.href);
              originUrl = new URL(self.location.origin);
              if (url.host !== originUrl.host) {
                return [
                  2
                  /*return*/
                ];
              }
              return [4, getWindowClient(url)];
            case 1:
              client = _c.sent();
              if (!!client) return [3, 4];
              return [4, self.clients.openWindow(link)];
            case 2:
              client = _c.sent();
              return [4, sleep2(FOREGROUND_HANDLE_PREPARATION_TIME_MS)];
            case 3:
              _c.sent();
              return [3, 6];
            case 4:
              return [4, client.focus()];
            case 5:
              client = _c.sent();
              _c.label = 6;
            case 6:
              if (!client) {
                return [
                  2
                  /*return*/
                ];
              }
              internalPayload.messageType = MessageType.NOTIFICATION_CLICKED;
              internalPayload.isFirebaseMessaging = true;
              return [2, client.postMessage(internalPayload)];
          }
        });
      });
    };
    return SwController2;
  }()
);
function wrapInternalPayload(internalPayload) {
  var _a3;
  var wrappedInternalPayload = __assign({}, internalPayload.notification);
  wrappedInternalPayload.data = (_a3 = {}, _a3[FCM_MSG] = internalPayload, _a3);
  return wrappedInternalPayload;
}
function getMessagePayloadInternal(_a3) {
  var data = _a3.data;
  if (!data) {
    return null;
  }
  try {
    return data.json();
  } catch (err) {
    return null;
  }
}
function getWindowClient(url) {
  return __awaiter(this, void 0, void 0, function() {
    var clientList, clientList_1, clientList_1_1, client, clientUrl;
    var e_1, _a3;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, getClientList()];
        case 1:
          clientList = _b.sent();
          try {
            for (clientList_1 = __values(clientList), clientList_1_1 = clientList_1.next(); !clientList_1_1.done; clientList_1_1 = clientList_1.next()) {
              client = clientList_1_1.value;
              clientUrl = new URL(client.url, self.location.href);
              if (url.host === clientUrl.host) {
                return [2, client];
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (clientList_1_1 && !clientList_1_1.done && (_a3 = clientList_1.return)) _a3.call(clientList_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return [2, null];
      }
    });
  });
}
function hasVisibleClients(clientList) {
  return clientList.some(function(client) {
    return client.visibilityState === "visible" && // Ignore chrome-extension clients as that matches the background pages of extensions, which
    // are always considered visible for some reason.
    !client.url.startsWith("chrome-extension://");
  });
}
function sendMessagePayloadInternalToWindows(clientList, internalPayload) {
  var e_2, _a3;
  internalPayload.isFirebaseMessaging = true;
  internalPayload.messageType = MessageType.PUSH_RECEIVED;
  try {
    for (var clientList_2 = __values(clientList), clientList_2_1 = clientList_2.next(); !clientList_2_1.done; clientList_2_1 = clientList_2.next()) {
      var client = clientList_2_1.value;
      client.postMessage(internalPayload);
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (clientList_2_1 && !clientList_2_1.done && (_a3 = clientList_2.return)) _a3.call(clientList_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
}
function getClientList() {
  return self.clients.matchAll({
    type: "window",
    includeUncontrolled: true
    // TS doesn't know that "type: 'window'" means it'll return WindowClient[]
  });
}
function showNotification(notificationPayloadInternal) {
  var _a3;
  var actions = notificationPayloadInternal.actions;
  var maxActions = Notification.maxActions;
  if (actions && maxActions && actions.length > maxActions) {
    console.warn("This browser only supports " + maxActions + " actions. The remaining actions will not be displayed.");
  }
  return self.registration.showNotification(
    /* title= */
    (_a3 = notificationPayloadInternal.title) !== null && _a3 !== void 0 ? _a3 : "",
    notificationPayloadInternal
  );
}
function getLink(payload) {
  var _a3, _b, _c;
  var link = (_b = (_a3 = payload.fcmOptions) === null || _a3 === void 0 ? void 0 : _a3.link) !== null && _b !== void 0 ? _b : (_c = payload.notification) === null || _c === void 0 ? void 0 : _c.click_action;
  if (link) {
    return link;
  }
  if (isConsoleMessage(payload.data)) {
    return self.location.origin;
  } else {
    return null;
  }
}
var WindowController = (
  /** @class */
  function() {
    function WindowController2(firebaseDependencies) {
      var _this = this;
      this.firebaseDependencies = firebaseDependencies;
      this.vapidKey = null;
      this.onMessageCallback = null;
      navigator.serviceWorker.addEventListener("message", function(e) {
        return _this.messageEventListener(e);
      });
    }
    Object.defineProperty(WindowController2.prototype, "app", {
      get: function() {
        return this.firebaseDependencies.app;
      },
      enumerable: false,
      configurable: true
    });
    WindowController2.prototype.messageEventListener = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, dataPayload;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              internalPayload = event.data;
              if (!internalPayload.isFirebaseMessaging) {
                return [
                  2
                  /*return*/
                ];
              }
              if (this.onMessageCallback && internalPayload.messageType === MessageType.PUSH_RECEIVED) {
                if (typeof this.onMessageCallback === "function") {
                  this.onMessageCallback(stripInternalFields(Object.assign({}, internalPayload)));
                } else {
                  this.onMessageCallback.next(Object.assign({}, internalPayload));
                }
              }
              dataPayload = internalPayload.data;
              if (!(isConsoleMessage(dataPayload) && dataPayload[CONSOLE_CAMPAIGN_ANALYTICS_ENABLED] === "1")) return [3, 2];
              return [4, this.logEvent(internalPayload.messageType, dataPayload)];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.getVapidKey = function() {
      return this.vapidKey;
    };
    WindowController2.prototype.getSwReg = function() {
      return this.swRegistration;
    };
    WindowController2.prototype.getToken = function(options) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!(Notification.permission === "default")) return [3, 2];
              return [4, Notification.requestPermission()];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              if (Notification.permission !== "granted") {
                throw ERROR_FACTORY2.create(
                  "permission-blocked"
                  /* PERMISSION_BLOCKED */
                );
              }
              return [4, this.updateVapidKey(options === null || options === void 0 ? void 0 : options.vapidKey)];
            case 3:
              _a3.sent();
              return [4, this.updateSwReg(options === null || options === void 0 ? void 0 : options.serviceWorkerRegistration)];
            case 4:
              _a3.sent();
              return [2, getToken2(this.firebaseDependencies, this.swRegistration, this.vapidKey)];
          }
        });
      });
    };
    WindowController2.prototype.updateVapidKey = function(vapidKey) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a3) {
          if (!!vapidKey) {
            this.vapidKey = vapidKey;
          } else if (!this.vapidKey) {
            this.vapidKey = DEFAULT_VAPID_KEY;
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    WindowController2.prototype.updateSwReg = function(swRegistration) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!(!swRegistration && !this.swRegistration)) return [3, 2];
              return [4, this.registerDefaultSw()];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              if (!swRegistration && !!this.swRegistration) {
                return [
                  2
                  /*return*/
                ];
              }
              if (!(swRegistration instanceof ServiceWorkerRegistration)) {
                throw ERROR_FACTORY2.create(
                  "invalid-sw-registration"
                  /* INVALID_SW_REGISTRATION */
                );
              }
              this.swRegistration = swRegistration;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.registerDefaultSw = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a3, e_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 2, , 3]);
              _a3 = this;
              return [4, navigator.serviceWorker.register(DEFAULT_SW_PATH, {
                scope: DEFAULT_SW_SCOPE
              })];
            case 1:
              _a3.swRegistration = _b.sent();
              this.swRegistration.update().catch(function() {
              });
              return [3, 3];
            case 2:
              e_1 = _b.sent();
              throw ERROR_FACTORY2.create("failed-service-worker-registration", {
                browserErrorMessage: e_1.message
              });
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.deleteToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!!this.swRegistration) return [3, 2];
              return [4, this.registerDefaultSw()];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              return [2, deleteToken(this.firebaseDependencies, this.swRegistration)];
          }
        });
      });
    };
    WindowController2.prototype.requestPermission = function() {
      return __awaiter(this, void 0, void 0, function() {
        var permissionResult;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (Notification.permission === "granted") {
                return [
                  2
                  /*return*/
                ];
              }
              return [4, Notification.requestPermission()];
            case 1:
              permissionResult = _a3.sent();
              if (permissionResult === "granted") {
                return [
                  2
                  /*return*/
                ];
              } else if (permissionResult === "denied") {
                throw ERROR_FACTORY2.create(
                  "permission-blocked"
                  /* PERMISSION_BLOCKED */
                );
              } else {
                throw ERROR_FACTORY2.create(
                  "permission-default"
                  /* PERMISSION_DEFAULT */
                );
              }
          }
        });
      });
    };
    WindowController2.prototype.usePublicVapidKey = function(vapidKey) {
      if (this.vapidKey !== null) {
        throw ERROR_FACTORY2.create(
          "use-vapid-key-after-get-token"
          /* USE_VAPID_KEY_AFTER_GET_TOKEN */
        );
      }
      if (typeof vapidKey !== "string" || vapidKey.length === 0) {
        throw ERROR_FACTORY2.create(
          "invalid-vapid-key"
          /* INVALID_VAPID_KEY */
        );
      }
      this.vapidKey = vapidKey;
    };
    WindowController2.prototype.useServiceWorker = function(swRegistration) {
      if (!(swRegistration instanceof ServiceWorkerRegistration)) {
        throw ERROR_FACTORY2.create(
          "invalid-sw-registration"
          /* INVALID_SW_REGISTRATION */
        );
      }
      if (this.swRegistration) {
        throw ERROR_FACTORY2.create(
          "use-sw-after-get-token"
          /* USE_SW_AFTER_GET_TOKEN */
        );
      }
      this.swRegistration = swRegistration;
    };
    WindowController2.prototype.onMessage = function(nextOrObserver) {
      var _this = this;
      this.onMessageCallback = nextOrObserver;
      return function() {
        _this.onMessageCallback = null;
      };
    };
    WindowController2.prototype.setBackgroundMessageHandler = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-sw"
        /* AVAILABLE_IN_SW */
      );
    };
    WindowController2.prototype.onBackgroundMessage = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-sw"
        /* AVAILABLE_IN_SW */
      );
    };
    WindowController2.prototype.onTokenRefresh = function() {
      return function() {
      };
    };
    WindowController2.prototype.logEvent = function(messageType, data) {
      return __awaiter(this, void 0, void 0, function() {
        var eventType, analytics;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              eventType = getEventType(messageType);
              return [4, this.firebaseDependencies.analyticsProvider.get()];
            case 1:
              analytics = _a3.sent();
              analytics.logEvent(eventType, {
                /* eslint-disable camelcase */
                message_id: data[CONSOLE_CAMPAIGN_ID],
                message_name: data[CONSOLE_CAMPAIGN_NAME],
                message_time: data[CONSOLE_CAMPAIGN_TIME],
                message_device_time: Math.floor(Date.now() / 1e3)
                /* eslint-enable camelcase */
              });
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return WindowController2;
  }()
);
function getEventType(messageType) {
  switch (messageType) {
    case MessageType.NOTIFICATION_CLICKED:
      return "notification_open";
    case MessageType.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
function stripInternalFields(internalPayload) {
  delete internalPayload.messageType;
  delete internalPayload.isFirebaseMessaging;
  return internalPayload;
}
function extractAppConfig2(app) {
  var e_1, _a3;
  if (!app || !app.options) {
    throw getMissingValueError2("App Configuration Object");
  }
  if (!app.name) {
    throw getMissingValueError2("App Name");
  }
  var configKeys = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ];
  var options = app.options;
  try {
    for (var configKeys_1 = __values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {
      var keyName = configKeys_1_1.value;
      if (!options[keyName]) {
        throw getMissingValueError2(keyName);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (configKeys_1_1 && !configKeys_1_1.done && (_a3 = configKeys_1.return)) _a3.call(configKeys_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return {
    appName: app.name,
    projectId: options.projectId,
    apiKey: options.apiKey,
    appId: options.appId,
    senderId: options.messagingSenderId
  };
}
function getMissingValueError2(valueName) {
  return ERROR_FACTORY2.create("missing-app-config-values", {
    valueName
  });
}
var MESSAGING_NAME = "messaging";
function factoryMethod(container) {
  var app = container.getProvider("app").getImmediate();
  var appConfig = extractAppConfig2(app);
  var installations = container.getProvider("installations").getImmediate();
  var analyticsProvider = container.getProvider("analytics-internal");
  var firebaseDependencies = {
    app,
    appConfig,
    installations,
    analyticsProvider
  };
  if (!isSupported()) {
    throw ERROR_FACTORY2.create(
      "unsupported-browser"
      /* UNSUPPORTED_BROWSER */
    );
  }
  if (self && "ServiceWorkerGlobalScope" in self) {
    return new SwController(firebaseDependencies);
  } else {
    return new WindowController(firebaseDependencies);
  }
}
var NAMESPACE_EXPORTS = {
  isSupported
};
index_esm_default.INTERNAL.registerComponent(new Component(
  MESSAGING_NAME,
  factoryMethod,
  "PUBLIC"
  /* PUBLIC */
).setServiceProps(NAMESPACE_EXPORTS));
function isSupported() {
  if (self && "ServiceWorkerGlobalScope" in self) {
    return isSWControllerSupported();
  } else {
    return isWindowControllerSupported();
  }
}
function isWindowControllerSupported() {
  return "indexedDB" in window && indexedDB !== null && navigator.cookieEnabled && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
function isSWControllerSupported() {
  return "indexedDB" in self && indexedDB !== null && "PushManager" in self && "Notification" in self && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
/*! Bundled license information:

@firebase/installations/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/messaging/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
   * in compliance with the License. You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under the License
   * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
   * or implied. See the License for the specific language governing permissions and limitations under
   * the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase_messaging.js.map
